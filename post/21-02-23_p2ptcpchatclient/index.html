<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>Breaking Down the Code; Creating a P2P Chat Client with C++ and QTNetwork. - Axel's Blog</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content><meta itemprop=name content="Breaking Down the Code; Creating a P2P Chat Client with C++ and QTNetwork."><meta itemprop=description content="In this blog post, we&rsquo;ll explore how to create a peer-to-peer chat client using C++ and QTNetwork. This chat client allows users to connect with each other using the TCP protocol, communicate through sending and receiving messages, and receive a list of connected peers on first connect. The chat client is designed to be extensible, with new peers being added dynamically, and with the ability to send and receive messages to and from all connected peers."><meta itemprop=datePublished content="2023-02-21T00:00:00+00:00"><meta itemprop=dateModified content="2023-02-21T00:00:00+00:00"><meta itemprop=wordCount content="2404"><meta itemprop=keywords content="programing,howto,story,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Breaking Down the Code; Creating a P2P Chat Client with C++ and QTNetwork."><meta name=twitter:description content="In this blog post, we&rsquo;ll explore how to create a peer-to-peer chat client using C++ and QTNetwork. This chat client allows users to connect with each other using the TCP protocol, communicate through sending and receiving messages, and receive a list of connected peers on first connect. The chat client is designed to be extensible, with new peers being added dynamically, and with the ability to send and receive messages to and from all connected peers."><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class="logo logo--mixed"><a class=logo__link href=/ title="Axel Vanherle" rel=home><div class="logo__item logo__imagebox"><img class=logo__img src=/img/icon.png></div><div class="logo__item logo__text"><div class=logo__title>Axel Vanherle</div><div class=logo__tagline>Electronics ICT Student with a passion for programming, automation, Linux, web design, DevOps, and anything related to free and open-source software.</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>About</span></a></li><li class=menu__item><a class=menu__link href=/projects/><span class=menu__text>Projects</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Breaking Down the Code; Creating a P2P Chat Client with C++ and QTNetwork.</h1><div class="post__meta meta"><div class="meta__item-author meta__item"><svg class="meta__icon icon icon-author" width="16" height="16" viewBox="0 0 12 16"><path d="M6 1c2.2.0 3.5 2 3.5 4.5C9.5 7 8.9 8.2 8 9c2.9.8 4 2.5 4 5v1H0v-1c0-2.5 1.1-4.2 4-5-.9-.8-1.5-2-1.5-3.5C2.5 3 3.8 1 6 1z"/></svg><span class=meta__text>Axel Vanherle</span></div><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2023-02-21T00:00:00Z>21-02-2023</time></div><div class="meta__item-categories meta__item"><svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2 1 2h8v11H0V2z"/></svg><span class=meta__text><a class=meta__link href=/categories/tutorial/ rel=category>Tutorial</a>, <a class=meta__link href=/categories/coding/ rel=category>Coding</a></span></div></div></header><div class="content post__content clearfix"><p>In this blog post, we&rsquo;ll explore how to create a peer-to-peer chat client using C++ and QTNetwork. This chat client allows users to connect with each other using the TCP protocol, communicate through sending and receiving messages, and receive a list of connected peers on first connect. The chat client is designed to be extensible, with new peers being added dynamically, and with the ability to send and receive messages to and from all connected peers.</p><p>This was all done for the course in network programming, but I added some extra features that weren&rsquo;t required, leveling up my skills in Qt, so to speak.</p><p>But what was the challenge? Before I explain my code, I&rsquo;m going to talk about what the end result should&rsquo;ve been.</p><p>As part of their coursework, each student was required to create a TCP peer-to-peer chat client using C++ OOP style. This involved creating a chat client that could connect with one other peer, with the IP address provided as a command line argument. The first peer, however, did not require an argument. When a client first connects, the chat client needed to be able to receive a list of other peers from the first peer, and connect to these new peers. Finally, the chat client needed to be capable of sending and receiving messages to and from all other peers in the network. Overall, this project required students to demonstrate their understanding of fundamental concepts in network programming, as well as their ability to apply these concepts in a practical project.</p><p>If this is still not clear, have a look at this image. This explain the topology of a peer-to-peer network. Compare this to the topology of a regular chat service, where the server is responsible for sending and receiving all messages to and from clients.</p><table><thead><tr><th style=text-align:center>peer-to-peer</th><th style=text-align:center>server based</th></tr></thead><tbody><tr><td style=text-align:center><img src=/img/21-02-23_p2ptcpchatclient/P2P_network.png alt=p2pexample></td><td style=text-align:center><img src=/img/21-02-23_p2ptcpchatclient/Server_network.png alt=serverexample></td></tr></tbody></table><p>Now that you know what the project is about, I will explain my code and why I did certain things as best as I can. I will be using small code blocks, to explain my code in sections to make it easier to understand. Note that I am not writing this blog post to boast or even attempt to teach anyone anything. I simply enjoy writing and plan to maintain this blog, so I can look back on it in the future. If someone picks something up or learns something new, even better. To get a bigger picture of the entire project, head to the GitHub found <a href=https://github.com/axelvanherle/P2P-TCP-chatclient-NP>here</a>.</p><p>Let&rsquo;s start where the code starts, in the main. The entire <code>main.cpp</code> file can be found <a href=https://github.com/axelvanherle/P2P-TCP-chatclient-NP/blob/main/p2pchatclient/main.cpp>here</a>, I will be pulling code blocks from this and explaining it in more detail.</p><p>It starts with the includes. These are needed for the various functions i use later on. Most noteworthy are these;</p><ul><li><code>&lt;QObject></code>: This header is used for QObject, which is the base class for all Qt objects that can emit signals and slots.</li><li><code>&lt;QTcpSocket></code> and <code>&lt;QTcpServer></code>: These headers provide classes for creating TCP clients and servers, respectively, for network communication.</li><li><code>&lt;QAbstractSocket></code>: This header provides an abstract base class for all socket classes in Qt.</li><li><code>&lt;QDebug></code>: This header provides debugging and logging functionality.</li><li><code>&lt;QInputDialog></code>: This header provides a class for creating dialog boxes that prompt the user for input.</li><li><code>&lt;QApplication></code> and <code>&lt;QtWidgets></code>: These headers are used for creating GUI applications with Qt, including widgets and other graphical elements.</li></ul><p>For some reference, I will be explaining my code in this format;</p><pre tabindex=0><code>code here
</code></pre><p>Explanation here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>QApplication <span style=color:#a6e22e>a</span>(argc, argv);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TcpClient client;
</span></span></code></pre></div><p>After the includes are done I initialize a Qt application using the <code>QApplication</code> class and creates an instance of it named <code>a</code>. The <code>TcpClient</code> object is then created using the default constructor.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>QLabel<span style=color:#f92672>*</span> outputLabel <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QLabel(<span style=color:#e6db74>&#34;Enter message:&#34;</span>);
</span></span><span style=display:flex><span>QLineEdit<span style=color:#f92672>*</span> inputLineEdit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QLineEdit();
</span></span><span style=display:flex><span>QPushButton<span style=color:#f92672>*</span> sendButton <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QPushButton(<span style=color:#e6db74>&#34;Send&#34;</span>);
</span></span><span style=display:flex><span>QLabel<span style=color:#f92672>*</span> inputLabel <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QLabel(<span style=color:#e6db74>&#34;Received messages:&#34;</span>);
</span></span><span style=display:flex><span>QPlainTextEdit<span style=color:#f92672>*</span> receivedTextEdit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QPlainTextEdit();
</span></span><span style=display:flex><span>receivedTextEdit<span style=color:#f92672>-&gt;</span>setReadOnly(true);
</span></span><span style=display:flex><span>receivedTextEdit<span style=color:#f92672>-&gt;</span>setMaximumBlockCount(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>QLabel<span style=color:#f92672>*</span> debugLabel <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QLabel(<span style=color:#e6db74>&#34;Debug messages:&#34;</span>);
</span></span><span style=display:flex><span>QPlainTextEdit<span style=color:#f92672>*</span> debugTextEdit <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QPlainTextEdit();
</span></span><span style=display:flex><span>debugTextEdit<span style=color:#f92672>-&gt;</span>setReadOnly(true);
</span></span><span style=display:flex><span>debugTextEdit<span style=color:#f92672>-&gt;</span>setMaximumHeight(<span style=color:#ae81ff>110</span>);
</span></span><span style=display:flex><span>debugTextEdit<span style=color:#f92672>-&gt;</span>setMaximumBlockCount(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>debugTextEdit<span style=color:#f92672>-&gt;</span>setStyleSheet(<span style=color:#e6db74>&#34;color: red;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>QVBoxLayout<span style=color:#f92672>*</span> layout <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QVBoxLayout();
</span></span><span style=display:flex><span>layout<span style=color:#f92672>-&gt;</span>addWidget(outputLabel);
</span></span><span style=display:flex><span>layout<span style=color:#f92672>-&gt;</span>addWidget(inputLineEdit);
</span></span><span style=display:flex><span>layout<span style=color:#f92672>-&gt;</span>addWidget(sendButton);
</span></span><span style=display:flex><span>layout<span style=color:#f92672>-&gt;</span>addWidget(inputLabel);
</span></span><span style=display:flex><span>layout<span style=color:#f92672>-&gt;</span>addWidget(receivedTextEdit);
</span></span><span style=display:flex><span>layout<span style=color:#f92672>-&gt;</span>addWidget(debugLabel);
</span></span><span style=display:flex><span>layout<span style=color:#f92672>-&gt;</span>addWidget(debugTextEdit);
</span></span><span style=display:flex><span>window.setLayout(layout);
</span></span></code></pre></div><p>This code block creates a GUI with several widgets using the Qt library.</p><p>The widgets created are:</p><ul><li><code>outputLabel</code>: a <code>QLabel</code> widget with the text &ldquo;Enter message:&rdquo;</li><li><code>inputLineEdit</code>: a<code> QLineEdit</code> widget for the user to enter text</li><li><code>sendButton</code>: a <code>QPushButton</code> widget with the text &ldquo;Send&rdquo;</li><li><code>inputLabel</code>: a <code>QLabel</code> widget with the text &ldquo;Received messages:&rdquo;</li><li><code>receivedTextEdit</code>: a <code>QPlainTextEdit</code> widget for displaying received messages. It is set to read-only, has a maximum block count of 100, - and is able to display multiple lines of text.</li><li><code>debugLabel</code>: a <code>QLabel</code> widget with the text &ldquo;Debug messages:&rdquo;</li><li><code>debugTextEdit</code>: a <code>QPlainTextEdit</code> widget for displaying debug messages. It is set to read-only, has a maximum height of 110 pixels, has a maximum block count of 100, and is styled with red text.</li></ul><p>The widgets are then added to a <code>QVBoxLayout</code>, which is a vertical layout manager that arranges the widgets vertically. Finally, the layout is set as the layout for the window widget.</p><p>Here is how it looks;</p><table><thead><tr><th style=text-align:center>example 1</th><th style=text-align:center>example 2</th></tr></thead><tbody><tr><td style=text-align:center><img src=/img/21-02-23_p2ptcpchatclient/ex1.png alt=p2pexample></td><td style=text-align:center><img src=/img/21-02-23_p2ptcpchatclient/ex2.png alt=serverexample></td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    client.firstConnect(argv[<span style=color:#ae81ff>1</span>], atoi(argv[<span style=color:#ae81ff>2</span>]));
</span></span></code></pre></div><p>Then there&rsquo;s this part. It doesn&rsquo;t do much; it simply checks whether command line arguments have been passed. If they have, the <code>firstConnect</code> function is called.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>QObject<span style=color:#f92672>::</span>connect(<span style=color:#f92672>&amp;</span>client, <span style=color:#f92672>&amp;</span>TcpClient<span style=color:#f92672>::</span>newConnection, [<span style=color:#f92672>&amp;</span>](QTcpSocket <span style=color:#f92672>*</span>socket)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    qDebug() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;New connection from: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> socket<span style=color:#f92672>-&gt;</span>peerAddress().toString();
</span></span><span style=display:flex><span>    debugTextEdit<span style=color:#f92672>-&gt;</span>appendPlainText(<span style=color:#e6db74>&#34;New connection from: &#34;</span> <span style=color:#f92672>+</span> socket<span style=color:#f92672>-&gt;</span>peerAddress().toString());
</span></span><span style=display:flex><span>    QObject<span style=color:#f92672>::</span>connect(socket, <span style=color:#f92672>&amp;</span>QTcpSocket<span style=color:#f92672>::</span>readyRead, <span style=color:#f92672>&amp;</span>client, <span style=color:#f92672>&amp;</span>TcpClient<span style=color:#f92672>::</span>readFromAll);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>This snippet creates a connection between a <code>QTcpSocket</code> and the <code>TcpClient</code> object. When a new connection is made, it prints the peer address and sets up a signal-slot connection to read incoming data from all connected sockets. The code is a lambda function that is executed when a new connection is made that takes a <code>QTcpSocket</code> pointer as its argument. This function first prints the peer address of the socket using <code>qDebug()</code>. It then appends the same information to the <code>debugTextEdit</code> using <code>appendPlainText()</code>. Finally, it sets up a signal-slot connection between the socket&rsquo;s <code>readyRead</code> signal and the <code>readFromAll</code> slot of the <code>TcpClient</code> object using the <code>QObject::connect()</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>QObject<span style=color:#f92672>::</span>connect(<span style=color:#f92672>&amp;</span>client, <span style=color:#f92672>&amp;</span>TcpClient<span style=color:#f92672>::</span>newMessageReceived, [<span style=color:#f92672>&amp;</span>](QString message)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    qDebug() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;New message received: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> message;
</span></span><span style=display:flex><span>    receivedTextEdit<span style=color:#f92672>-&gt;</span>appendPlainText(message);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>This code uses a lambda function to connect the <code>newMessageReceived</code> signal of the <code>TcpClient</code> object to a slot. When a new message is received, the signal is emitted and the lambda function is called. The function then logs the received message using <code>qDebug</code> and appends it to the <code>receivedTextEdit</code> widget.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>QObject<span style=color:#f92672>::</span>connect(sendButton, <span style=color:#f92672>&amp;</span>QPushButton<span style=color:#f92672>::</span>clicked, [<span style=color:#f92672>&amp;</span>]()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    QString message <span style=color:#f92672>=</span> inputLineEdit<span style=color:#f92672>-&gt;</span>text();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (message.isEmpty())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Show message box with error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        QMessageBox<span style=color:#f92672>::</span>warning(<span style=color:#f92672>&amp;</span>window, <span style=color:#e6db74>&#34;Error&#34;</span>, <span style=color:#e6db74>&#34;Message cannot be empty!&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    qDebug() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Message sent: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> message;
</span></span><span style=display:flex><span>    debugTextEdit<span style=color:#f92672>-&gt;</span>appendPlainText(<span style=color:#e6db74>&#34;Message sent: &#34;</span> <span style=color:#f92672>+</span> message);
</span></span><span style=display:flex><span>    client.sendToAll(message);
</span></span><span style=display:flex><span>    inputLineEdit<span style=color:#f92672>-&gt;</span>clear();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>This is a lambda function that is used to connect the click signal of the <code>sendButton</code> to a slot that sends a message to all peers. When the <code>sendButton</code> is clicked, the function gets executed. It first retrieves the message entered by the user from the <code>inputLineEdit</code>, and checks if it is empty. If it is, it displays an error message using a <code>QMessageBox</code>. Otherwise, it logs the message to the <code>debugTextEdit</code>, sends it to all connected peers using the <code>sendToAll</code> function of the <code>TcpClient</code> object, and clears the <code>inputLineEdit</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>window.show();
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> a.exec();
</span></span></code></pre></div><p>And here we are, at the end of the main with the last two lines, but fear not; there is more. <code>window.show()</code> makes the window visible to the user. The second line <code>return a.exec()</code> starts the event loop of the Qt application, which waits for and processes events.</p><p>Now we move on to the <code>TcpClient</code> class. I will not be explaining the header file at all, since this is just the declaration of the functions, slots, etc. The header file can be found <a href=https://github.com/axelvanherle/P2P-TCP-chatclient-NP/blob/main/p2pchatclient/tcpclient.h>here</a> and the C++ file can be found <a href=https://github.com/axelvanherle/P2P-TCP-chatclient-NP/blob/main/p2pchatclient/tcpclient.cpp>here</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>TcpClient<span style=color:#f92672>::</span>TcpClient(QObject <span style=color:#f92672>*</span>parent)
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> QObject(parent)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create the server socket and listen for connections
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    server <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QTcpServer(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    connect(server, SIGNAL(newConnection()), <span style=color:#66d9ef>this</span>, SLOT(handleNewConnection()));
</span></span><span style=display:flex><span>    server<span style=color:#f92672>-&gt;</span>listen(QHostAddress<span style=color:#f92672>::</span>Any, <span style=color:#ae81ff>24042</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code snippet defines the constructor for the <code>TcpClient</code> class, which is a subclass of the <code>QObject</code> class. This initializes the server socket, connects the <code>newConnection()</code> signal to the <code>handleNewConnection()</code> slot to handle new connections (this is self-explanatory), and starts listening for incoming connections on a specified port number. This means that when a new connection is made, the <code>handleNewConnection()</code> slot will be called.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> TcpClient<span style=color:#f92672>::</span>handleNewConnection()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    QTcpSocket <span style=color:#f92672>*</span>socket <span style=color:#f92672>=</span> server<span style=color:#f92672>-&gt;</span>nextPendingConnection();
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string peers <span style=color:#f92672>=</span> getPeers();
</span></span><span style=display:flex><span>    socket<span style=color:#f92672>-&gt;</span>write(peers.c_str());
</span></span><span style=display:flex><span>    connect(socket, SIGNAL(readyRead()), <span style=color:#66d9ef>this</span>, SLOT(readFromAll()));
</span></span><span style=display:flex><span>    m_sockets.append(socket);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    emit <span style=color:#a6e22e>newConnection</span>(socket);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we define the <code>handleNewConnection()</code> slot. The purpose of this slot is to handle a new incoming connection from a client to the server. It also sends the list of currently connected peers to the new client using the <code>getPeers()</code> function, connects the <code>readyRead()</code> signal of the socket to the <code>readFromAll()</code> slot of the <code>TcpClient</code> object, adds the socket to the list of connected sockets, and emits a <code>newConnection()</code> signal to indicate that a new client has connected.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> TcpClient<span style=color:#f92672>::</span>sendToAll(QString message)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (QTcpSocket <span style=color:#f92672>*</span>socket : m_sockets)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        socket<span style=color:#f92672>-&gt;</span>write(message.toUtf8());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code snippet defines the <code>sendToAll()</code> function. This function allows for the <code>TcpClient</code> object to send a message to all currently connected clients with a single call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> TcpClient<span style=color:#f92672>::</span>readFromAll()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (QTcpSocket <span style=color:#f92672>*</span>socket : m_sockets)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (socket<span style=color:#f92672>-&gt;</span>bytesAvailable() <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            QString message <span style=color:#f92672>=</span> QString<span style=color:#f92672>::</span>fromUtf8(socket<span style=color:#f92672>-&gt;</span>readAll());
</span></span><span style=display:flex><span>            emit <span style=color:#a6e22e>newMessageReceived</span>(message);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code snippet defines the <code>readFromAll()</code> slot for the class. The purpose of this slot is to read incoming data from all connected clients and emit a signal for each new message received. It uses a for each loop to iterate over the list of sockets, and check each one if there is data available to read. After reading, it converts it to a <code>QString</code> object, and emits a <code>newMessageReceived()</code> signal for each new message received.</p><p>Now here&rsquo;s a big boy code block, are you ready?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> TcpClient<span style=color:#f92672>::</span>firstConnect(std<span style=color:#f92672>::</span>string firstIp, <span style=color:#66d9ef>int</span> firstPort)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    QTcpSocket <span style=color:#f92672>*</span>firstSocket <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QTcpSocket(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get me a damn socket! Grrrr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    firstSocket<span style=color:#f92672>-&gt;</span>connectToHost(firstIp.c_str(), firstPort);
</span></span><span style=display:flex><span>    firstSocket<span style=color:#f92672>-&gt;</span>write(<span style=color:#e6db74>&#34;Hello there!&#34;</span>);
</span></span><span style=display:flex><span>    firstSocket<span style=color:#f92672>-&gt;</span>waitForBytesWritten(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    firstSocket<span style=color:#f92672>-&gt;</span>waitForReadyRead(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (firstSocket<span style=color:#f92672>-&gt;</span>waitForConnected())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        connect(firstSocket, SIGNAL(readyRead()), <span style=color:#66d9ef>this</span>, SLOT(readFromAll()));
</span></span><span style=display:flex><span>        m_sockets.append(firstSocket);
</span></span><span style=display:flex><span>        emit <span style=color:#a6e22e>newConnection</span>(firstSocket);
</span></span><span style=display:flex><span>        qDebug() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Connected to: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> firstIp.c_str() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> firstSocket;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string recv;
</span></span><span style=display:flex><span>        recv <span style=color:#f92672>=</span> firstSocket<span style=color:#f92672>-&gt;</span>readAll();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Parse the received buffer filled with new IP and Ports.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>istringstream ss(recv);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>string token, newIP, newPort;
</span></span><span style=display:flex><span>        getline(ss, token); <span style=color:#75715e>// discard first line
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (getline(ss, token))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>string temp;
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>stringstream tokenStream(token);
</span></span><span style=display:flex><span>            getline(tokenStream, newIP, <span style=color:#e6db74>&#39;:&#39;</span>);
</span></span><span style=display:flex><span>            getline(tokenStream, newPort);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            QTcpSocket <span style=color:#f92672>*</span>socket <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> QTcpSocket(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            socket<span style=color:#f92672>-&gt;</span>connectToHost(newIP.c_str(), atoi(newPort.c_str()));
</span></span><span style=display:flex><span>            socket<span style=color:#f92672>-&gt;</span>write(<span style=color:#e6db74>&#34;Hello there!&#34;</span>);
</span></span><span style=display:flex><span>            socket<span style=color:#f92672>-&gt;</span>waitForBytesWritten(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>            socket<span style=color:#f92672>-&gt;</span>waitForReadyRead(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            temp <span style=color:#f92672>=</span> socket<span style=color:#f92672>-&gt;</span>readAll();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Are we connected?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (socket<span style=color:#f92672>-&gt;</span>state() <span style=color:#f92672>==</span> QAbstractSocket<span style=color:#f92672>::</span>ConnectedState)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Connected to &#34;</span> <span style=color:#f92672>&lt;&lt;</span> newIP <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> newPort <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34; successfully!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>                connect(socket, SIGNAL(readyRead()), <span style=color:#66d9ef>this</span>, SLOT(readFromAll()));
</span></span><span style=display:flex><span>                m_sockets.append(socket);
</span></span><span style=display:flex><span>                emit <span style=color:#a6e22e>newConnection</span>(socket);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Failed to connect to &#34;</span> <span style=color:#f92672>&lt;&lt;</span> newIP <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> newPort <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;.&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        qDebug() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Failed to connect to: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> firstIp.c_str() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>&lt;&lt;</span> firstSocket;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code defines the <code>firstConnect()</code> function that connects to a peer with the specified IP address and port number. It sends a <code>"Hello there!"</code> message to the peer, waits for a response and if the connection is successful, the function reads the response using the <code>readAll()</code> function, which returns the response as a string. It then parses this string to extract new IP addresses and port numbers using a <code>std::istringstream</code> object and a <code>getline()</code> function. It then connects to each of these new peers in turn, sending another <code>"Hello there!"</code> message and waiting for a response before adding them to the list of connected sockets. If the connection is successful, the function emits a <code>newConnection()</code> signal, adds the new socket to the list of connected sockets using the <code>append()</code> function, and connects the <code>readyRead()</code> signal of the new socket to the <code>readFromAll()</code> slot using the <code>connect()</code> function. If the connection fails, the function prints an error message to the console.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>string TcpClient<span style=color:#f92672>::</span>getPeers(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    QString peerList <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;NEWCON&#34;</span>;
</span></span><span style=display:flex><span>    peerList <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (QTcpSocket <span style=color:#f92672>*</span>socket : m_sockets)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(socket<span style=color:#f92672>-&gt;</span>state()<span style=color:#f92672>==</span> QTcpSocket<span style=color:#f92672>::</span>ConnectedState)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            QString address <span style=color:#f92672>=</span> QHostAddress(socket<span style=color:#f92672>-&gt;</span>peerAddress().toIPv4Address()).toString();
</span></span><span style=display:flex><span>            peerList <span style=color:#f92672>+=</span> address <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;24042&#34;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>string temp <span style=color:#f92672>=</span> peerList.toStdString();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> temp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function returns a list of peers connected to the <code>TcpClient</code> object as a string. The function first initializes the <code>peerList</code> variable with the string <code>"NEWCON"</code> followed by a newline character. Then, it loops through each socket in the <code>m_sockets</code> list and checks if it is in a connected state using the <code>QTcpSocket::state()</code> function. If the socket is connected, it retrieves the IP address of the peer using <code>socket->peerAddress().toIPv4Address()</code> and converts it to a <code>QString</code>. It then appends the IP address, followed by the string <code>":24042"</code> and a newline character, to the <code>peerList</code> variable. Finally, the function converts the variable to a <code>std::string</code> and returns it, for other functions to call and use.</p><p>In conclusion, I found this project to be very enjoyable and challenging. I had never worked with QT or C++ in this way before, so it&rsquo;s safe to say that it has leveled up my skills. This was similar to what happened last year in the networking course when I worked with C, which gave me a better understanding of C itself. It turns out that OOP is not such a bad thing after all, who would&rsquo;ve though? This project also gave me a better appreciation for QT. At the beginning of the project, I wanted to switch to Berkeley sockets like I was used to in C, but I ended up persevering and it was worth it. Not only am I now better at C++, but this is also my first GUI-based application! Hooray! I went beyond what I was supposed to do, and I have to say that I&rsquo;m pretty proud of it.</p><p>I do wonder how the rest of the class did on the project. I only got to see their work when I asked them in class, and it&rsquo;s a bit disappointing that no one else created a public repository like mine. I really enjoy reading through them. However, I don&rsquo;t think many people attempted the project, which doesn&rsquo;t bother me too much since creating it wasn&rsquo;t a requirement to get your grades. All other students were free to use the code created by any other student, without losing any grades for it. Additionally, the next assignment is an individual project worth 4x more, so this project was just an introduction to the next one for me.</p><p>I hope you enjoyed reading this post! If you have any questions or if there&rsquo;s something you don&rsquo;t understand, don&rsquo;t hesitate to ask.</p></div><footer class=post__footer><div class="post__tags tags clearfix"><svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5.0 11V3C0 1.5.8.8.8.8S1.5.0 3 0h8c1.5.0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 100-6 3 3 0 000 6z"/></svg><ul class=tags__list><li class=tags__item><a class="tags__link btn" href=/tags/programing/ rel=tag>programing</a></li><li class=tags__item><a class="tags__link btn" href=/tags/howto/ rel=tag>howto</a></li><li class=tags__item><a class="tags__link btn" href=/tags/story/ rel=tag>story</a></li></ul></div></footer></article></main><nav class="pager flex"><div class="pager__item pager__item--prev"><a class=pager__link href=/post/20-02-22_howigotthisup/ rel=prev><span class=pager__subtitle>«&#8201;Previous</span><p class=pager__title>How i got this website up and running.</p></a></div><div class="pager__item pager__item--next"><a class=pager__link href=/post/22-02-23_zerotodnshero/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>From Zero to DNS Hero; My Journey Setting Up a Blog with a Custom Domain</p></a></div></nav></div><aside class="sidebar sidebar--left"><div class="widget-social widget"><h4 class="widget-social__title widget__title">Social</h4><div class="widget-social__content widget__content"><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=LinkedIn rel="noopener noreferrer" href=https://linkedin.com/in/axelvanherle target=_blank><svg class="widget-social__link-icon icon icon-linkedin" width="24" height="24" viewBox="0 0 352 352"><path d="M0 40v272c0 21.9 18.1 40 40 40h272c21.9.0 40-18.1 40-40V40c0-21.9-18.1-40-40-40H40C18.1.0.0 18.1.0 40zm312-8c4.6.0 8 3.4 8 8v272c0 4.6-3.4 8-8 8H40c-4.6.0-8-3.4-8-8V40c0-4.6 3.4-8 8-8H312zM59.5 87c0 15.2 12.3 27.5 27.5 27.5s27.5-12.3 27.5-27.5S102.2 59.5 87 59.5 59.5 71.8 59.5 87zM187 157h-1v-21h-45v152h47v-75c0-19.8 3.9-39 28.5-39 24.2.0 24.5 22.4 24.5 40v74h47v-83.5c0-40.9-8.7-72-56.5-72-23 0-38.2 12.6-44.5 24.5zM64 288h47.5V136H64V288z"/></svg><span>LinkedIn</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=GitHub rel="noopener noreferrer" href=https://github.com/axelvanherle target=_blank><svg class="widget-social__link-icon icon icon-github" width="24" height="24" viewBox="0 0 384 374"><path d="m192 0C85.9.0.0 85.8.0 191.7c0 84.7 55 156.6 131.3 181.9 9.6 1.8 13.1-4.2 13.1-9.2.0-4.6-.2-16.6-.3-32.6-53.4 11.6-64.7-25.7-64.7-25.7-8.7-22.1-21.3-28-21.3-28-17.4-11.9 1.3-11.6 1.3-11.6 19.3 1.4 29.4 19.8 29.4 19.8 17.1 29.3 44.9 20.8 55.9 15.9 1.7-12.4 6.7-20.8 12.2-25.6-42.6-4.8-87.5-21.3-87.5-94.8.0-20.9 7.5-38 19.8-51.4-2-4.9-8.6-24.3 1.9-50.7.0.0 16.1-5.2 52.8 19.7 15.3-4.2 31.7-6.4 48.1-6.5 16.3.1 32.7 2.2 48.1 6.5 36.7-24.8 52.8-19.7 52.8-19.7 10.5 26.4 3.9 45.9 1.9 50.7 12.3 13.4 19.7 30.5 19.7 51.4.0 73.7-44.9 89.9-87.7 94.6 6.9 5.9 13 17.6 13 35.5.0 25.6-.2 46.3-.2 52.6.0 5.1 3.5 11.1 13.2 9.2C329 348.2 384 276.4 384 191.7 384 85.8 298 0 192 0z"/></svg><span>GitHub</span></a></div><div class="widget-social__item widget__item"><a class="widget-social__link widget__link btn" title=Email href=mailto:axelvanherle@outlook.com><svg class="widget-social__link-icon icon icon-mail" width="24" height="24" viewBox="0 0 416 288"><path d="m0 16v256 16h16 384 16v-16V16 0h-16H16 0zm347 16-139 92.5L69 32zM199 157.5l9 5.5 9-5.5L384 46v210H32V46z"/></svg><span>axelvanherle@outlook.com</span></a></div></div></div><div class="widget-categories widget"><h4 class=widget__title>Categories</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/categories/coding/>Coding</a></li><li class=widget__item><a class=widget__link href=/categories/life/>Life</a></li><li class=widget__item><a class=widget__link href=/categories/tutorial/>Tutorial</a></li></ul></div></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/post/22-02-23_zerotodnshero/>From Zero to DNS Hero; My Journey Setting Up a Blog with a Custom Domain</a></li><li class=widget__item><a class=widget__link href=/post/21-02-23_p2ptcpchatclient/>Breaking Down the Code; Creating a P2P Chat Client with C++ and QTNetwork.</a></li><li class=widget__item><a class=widget__link href=/post/20-02-22_howigotthisup/>How i got this website up and running.</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/tags/devops/ title=devops>devops (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/howto/ title=howto>howto (3)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/programing/ title=programing>programing (1)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/story/ title=story>story (2)</a>
<a class="widget-taglist__link widget__link btn" href=/tags/webdev/ title=webdev>webdev (2)</a></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2023 Axel Vanherle.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>